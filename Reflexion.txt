Reflexión 
Como grupo hemos realizado una representación en un diagrama UML como primera parte del desarrollo del proyecto designado en la primera unidad en la materia  P.O.O (Programación Orientada a Objetos) pero en esta segunda unidad se ha pasado el Diagrama ya ha código en JAVA. 
A continuación, realizaremos una breve descripción de la implementación de conocimientos conceptos del proyecto en ejecución, además de hacer mención de algunos de los mismos para hacer conocer cómo los hemos utilizado e implementado en el código desarrollado para su respectiva presentación.

Abstracción: (mesa, reserva, cliente, personal).
Se usó este método debido a que todas estas clases se relacionan entre sí y entre las mismas se abstraen atributos para que así no exista redundancia dentro del código para que este sea más claro y entendible para el usuario.

Encapsulamiento: (mesa y reserva)
Este método se ha usado dentro del mismo para tener un acceso directo a los atributos dentro de las clases mencionadas asegurando así que ,los cambios del estado tendrán validaciones específicas.

Herencia: (Persona (personal y cliente)) (ListaDeEspera)
Se usó el método para generalizar comportamientos comunes comparten atributos similares con Persona lo que permitió reutilizar lógica y evitar la redundancia en el código, además mencionar que esta clase lista de espera colaboran a que las clases base aseguren consistencias en el manejo de colecciones.

Polimorfismo: (modificarReserva (cliente y personal) (verificarDisponibilidadMesa)
Se aplicó el polimorfismo para realizar la reutilización y extensión del sistema como lo son cliente y personal usando métodos similares, pero con comportamientos ya adaptados a sus responsabilidades específicas dentro del código. Este enfoque facilita la expansión del sistema ya que se pudieron agregar funcionalidades sin alterar el código.

Cambios
Se agregaron algunos cambios en las relaciones por observaciones proporcionadas por el docente además que se realizaron algunas observaciones a nivel grupal lo que facilitó el entendimiento y desarrollo tanto del diagrama como del código proporcionado.

Decisiones de Diseño
Se simplificaron algunas relaciones bidimensionales con algunas clases para evitar las dependencias cíclicas entre clases lo que mejoró el modularidad en el diseño del diagrama para así poder realizar un código de manera más entendible sin ambigüedades y redundancias.

Se realizó un funcionamiento métodos como reserva y lista de espera el cual optimizó el rendimiento y claridad en el código presentado.

Algunos atributos se encapsularon como estructuras más complejas y mejorar el acceso y búsqueda.
